"""
Action Plan Models
Data structures for the agentic planning workflow.
These models represent the AI's plan before execution.
"""
from dataclasses import dataclass, field
from datetime import datetime
from typing import Any
from enum import Enum
import uuid


class PlanStepStatus(Enum):
    """Status of a plan step"""
    PENDING = "pending"
    EXECUTING = "executing"
    COMPLETED = "completed"
    FAILED = "failed"
    SKIPPED = "skipped"


class PlanStatus(Enum):
    """Status of the overall plan"""
    DRAFT = "draft"
    AWAITING_APPROVAL = "awaiting_approval"
    APPROVED = "approved"
    EXECUTING = "executing"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"


@dataclass
class PlanStep:
    """
    A single step in an action plan.
    Each step represents one action the AI will take.
    """
    action: str              # Function/handler name (e.g., "addToShoppingList")
    parameters: dict         # Arguments for the action
    description: str         # Human-readable description of what this step does
    reason: str              # Why this step is needed
    id: str = field(default_factory=lambda: str(uuid.uuid4())[:8])
    estimated_cost: float = 0.0
    status: PlanStepStatus = PlanStepStatus.PENDING
    result: Any = None
    error: str | None = None
    executed_at: datetime | None = None
    
    def to_conversational(self) -> str:
        """Convert step to friendly, conversational text"""
        return f"â€¢ {self.description}"
    
    def to_dict(self) -> dict:
        """Serialize for storage/transmission"""
        return {
            "id": self.id,
            "action": self.action,
            "parameters": self.parameters,
            "description": self.description,
            "reason": self.reason,
            "estimated_cost": self.estimated_cost,
            "status": self.status.value,
            "result": str(self.result) if self.result else None,
            "error": self.error,
        }


@dataclass
class ActionPlan:
    """
    A complete action plan generated by the AI.
    Contains all steps needed to accomplish the user's goal.
    """
    goal: str                    # High-level goal (user's intent)
    context: dict                # All gathered context (preferences, inventory, etc.)
    steps: list[PlanStep]
    id: str = field(default_factory=lambda: str(uuid.uuid4())[:12])
    total_estimated_cost: float = 0.0
    requires_approval: bool = False
    approval_reason: str | None = None
    status: PlanStatus = PlanStatus.DRAFT
    created_at: datetime = field(default_factory=datetime.now)
    completed_at: datetime | None = None
    execution_summary: str | None = None
    
    def add_step(self, step: PlanStep) -> None:
        """Add a step to the plan"""
        self.steps.append(step)
        self.total_estimated_cost += step.estimated_cost
    
    def get_pending_steps(self) -> list[PlanStep]:
        """Get all steps that haven't been executed yet"""
        return [s for s in self.steps if s.status == PlanStepStatus.PENDING]
    
    def get_completed_steps(self) -> list[PlanStep]:
        """Get all successfully completed steps"""
        return [s for s in self.steps if s.status == PlanStepStatus.COMPLETED]
    
    def get_failed_steps(self) -> list[PlanStep]:
        """Get all failed steps"""
        return [s for s in self.steps if s.status == PlanStepStatus.FAILED]
    
    def to_conversational(self) -> str:
        """
        Convert the plan to friendly, conversational text.
        NO CODE - just plain English that anyone can understand.
        """
        lines = [f"**Here's what I'm planning to do:**\n"]
        lines.append(f"ðŸŽ¯ **Goal:** {self.goal}\n")
        
        if self.steps:
            lines.append("**Steps:**")
            for i, step in enumerate(self.steps, 1):
                status_emoji = {
                    PlanStepStatus.PENDING: "â³",
                    PlanStepStatus.EXECUTING: "âš™ï¸",
                    PlanStepStatus.COMPLETED: "âœ…",
                    PlanStepStatus.FAILED: "âŒ",
                    PlanStepStatus.SKIPPED: "â­ï¸",
                }.get(step.status, "â€¢")
                
                lines.append(f"{i}. {status_emoji} {step.description}")
                if step.reason:
                    lines.append(f"   â†³ *{step.reason}*")
        
        if self.total_estimated_cost > 0:
            lines.append(f"\nðŸ’° **Estimated cost:** ${self.total_estimated_cost:.2f}")
        
        if self.requires_approval:
            lines.append(f"\nâš ï¸ **Needs your approval:** {self.approval_reason}")
            lines.append("\n*Reply 'yes' to proceed or 'no' to cancel.*")
        
        return "\n".join(lines)
    
    def to_execution_summary(self) -> str:
        """
        Generate a conversational summary after execution.
        """
        completed = self.get_completed_steps()
        failed = self.get_failed_steps()
        
        lines = ["**Here's what I did:**\n"]
        
        if completed:
            for step in completed:
                lines.append(f"âœ… {step.description}")
                if step.result and isinstance(step.result, str):
                    # Extract key info from result, keep it brief
                    result_preview = step.result[:150] + "..." if len(step.result) > 150 else step.result
                    if not result_preview.startswith("âœ…"):  # Avoid double checkmarks
                        lines.append(f"   â†’ {result_preview}")
        
        if failed:
            lines.append("\n**Some things didn't work:**")
            for step in failed:
                lines.append(f"âŒ {step.description}")
                if step.error:
                    lines.append(f"   â†’ {step.error}")
        
        if self.total_estimated_cost > 0:
            lines.append(f"\nðŸ’° **Total spent:** ${self.total_estimated_cost:.2f}")
        
        return "\n".join(lines)
    
    def to_dict(self) -> dict:
        """Serialize for storage/transmission"""
        return {
            "id": self.id,
            "goal": self.goal,
            "steps": [s.to_dict() for s in self.steps],
            "total_estimated_cost": self.total_estimated_cost,
            "requires_approval": self.requires_approval,
            "approval_reason": self.approval_reason,
            "status": self.status.value,
            "created_at": self.created_at.isoformat(),
        }


@dataclass
class AgentContext:
    """
    All context gathered during the planning phase.
    This is populated by calling all context-gathering functions in parallel.
    """
    user_id: str
    preferences: dict | None = None
    inventory: list[dict] = field(default_factory=list)
    leftovers: list[dict] = field(default_factory=list)
    shopping_list: list[dict] = field(default_factory=list)
    wallet_balance: float | None = None
    spending_limit_daily: float = 5.0  # Default auto-approve limit
    spending_limit_weekly: float = 50.0
    spent_today: float = 0.0
    gathered_at: datetime = field(default_factory=datetime.now)
    
    def to_summary(self) -> str:
        """Summarize context for LLM"""
        parts = []
        
        if self.preferences:
            dietary = self.preferences.get("dietary_restrictions", [])
            goals = self.preferences.get("health_goals", [])
            family = self.preferences.get("family_size", 1)
            parts.append(f"User preferences: Family of {family}, restrictions: {dietary}, goals: {goals}")
        
        if self.inventory:
            items = [i.get("item_name", i.get("item", "?")) for i in self.inventory[:10]]
            parts.append(f"Inventory ({len(self.inventory)} items): {', '.join(items)}")
        
        if self.leftovers:
            items = [l.get("meal_name", "?") for l in self.leftovers[:5]]
            parts.append(f"Leftovers: {', '.join(items)}")
        
        if self.shopping_list:
            items = [s.get("item", "?") for s in self.shopping_list[:10]]
            parts.append(f"Shopping list ({len(self.shopping_list)} items): {', '.join(items)}")
        
        if self.wallet_balance is not None:
            parts.append(f"Wallet balance: ${self.wallet_balance:.2f}")
            parts.append(f"Daily spending limit: ${self.spending_limit_daily:.2f}")
            parts.append(f"Spent today: ${self.spent_today:.2f}")
        
        return "\n".join(parts) if parts else "No context available"
    
    def get_remaining_budget(self) -> float:
        """Calculate remaining daily budget"""
        return max(0, self.spending_limit_daily - self.spent_today)
    
    def can_auto_approve(self, amount: float) -> bool:
        """Check if an amount can be auto-approved"""
        return amount <= self.get_remaining_budget()
